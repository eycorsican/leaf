// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `config.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Dns)
pub struct Dns {
    // message fields
    // @@protoc_insertion_point(field:Dns.servers)
    pub servers: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:Dns.hosts)
    pub hosts: ::std::collections::HashMap<::std::string::String, dns::Ips>,
    // special fields
    // @@protoc_insertion_point(special_field:Dns.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Dns {
    fn default() -> &'a Dns {
        <Dns as ::protobuf::Message>::default_instance()
    }
}

impl Dns {
    pub fn new() -> Dns {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Dns {
    const NAME: &'static str = "Dns";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.hosts.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for (k, v) in &self.hosts {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.servers {
            os.write_string(1, &v)?;
        };
        for (k, v) in &self.hosts {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Dns {
        Dns::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.hosts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Dns {
        static instance: ::protobuf::rt::Lazy<Dns> = ::protobuf::rt::Lazy::new();
        instance.get(Dns::new)
    }
}

/// Nested message and enums of message `Dns`
pub mod dns {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:Dns.Ips)
    pub struct Ips {
        // message fields
        // @@protoc_insertion_point(field:Dns.Ips.values)
        pub values: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:Dns.Ips.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Ips {
        fn default() -> &'a Ips {
            <Ips as ::protobuf::Message>::default_instance()
        }
    }

    impl Ips {
        pub fn new() -> Ips {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Ips {
        const NAME: &'static str = "Ips";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.values.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.values {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.values {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Ips {
            Ips::new()
        }

        fn clear(&mut self) {
            self.values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Ips {
            static instance: Ips = Ips {
                values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Log)
pub struct Log {
    // message fields
    // @@protoc_insertion_point(field:Log.level)
    pub level: ::protobuf::EnumOrUnknown<log::Level>,
    // @@protoc_insertion_point(field:Log.output)
    pub output: ::protobuf::EnumOrUnknown<log::Output>,
    // @@protoc_insertion_point(field:Log.output_file)
    pub output_file: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Log.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Log {
    const NAME: &'static str = "Log";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.output = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.output_file = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != ::protobuf::EnumOrUnknown::new(log::Level::INFO) {
            my_size += ::protobuf::rt::int32_size(1, self.level.value());
        }
        if self.output != ::protobuf::EnumOrUnknown::new(log::Output::CONSOLE) {
            my_size += ::protobuf::rt::int32_size(2, self.output.value());
        }
        if !self.output_file.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.output_file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != ::protobuf::EnumOrUnknown::new(log::Level::INFO) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
        }
        if self.output != ::protobuf::EnumOrUnknown::new(log::Output::CONSOLE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.output))?;
        }
        if !self.output_file.is_empty() {
            os.write_string(3, &self.output_file)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Log {
        Log::new()
    }

    fn clear(&mut self) {
        self.level = ::protobuf::EnumOrUnknown::new(log::Level::INFO);
        self.output = ::protobuf::EnumOrUnknown::new(log::Output::CONSOLE);
        self.output_file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Log {
        static instance: Log = Log {
            level: ::protobuf::EnumOrUnknown::from_i32(0),
            output: ::protobuf::EnumOrUnknown::from_i32(0),
            output_file: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Log`
pub mod log {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Log.Level)
    pub enum Level {
        // @@protoc_insertion_point(enum_value:Log.Level.INFO)
        INFO = 0,
        // @@protoc_insertion_point(enum_value:Log.Level.TRACE)
        TRACE = 1,
        // @@protoc_insertion_point(enum_value:Log.Level.DEBUG)
        DEBUG = 2,
        // @@protoc_insertion_point(enum_value:Log.Level.WARN)
        WARN = 3,
        // @@protoc_insertion_point(enum_value:Log.Level.ERROR)
        ERROR = 4,
    }

    impl ::protobuf::Enum for Level {
        const NAME: &'static str = "Level";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Level> {
            match value {
                0 => ::std::option::Option::Some(Level::INFO),
                1 => ::std::option::Option::Some(Level::TRACE),
                2 => ::std::option::Option::Some(Level::DEBUG),
                3 => ::std::option::Option::Some(Level::WARN),
                4 => ::std::option::Option::Some(Level::ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Level] = &[
            Level::INFO,
            Level::TRACE,
            Level::DEBUG,
            Level::WARN,
            Level::ERROR,
        ];
    }

    impl ::std::default::Default for Level {
        fn default() -> Self {
            Level::INFO
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Log.Output)
    pub enum Output {
        // @@protoc_insertion_point(enum_value:Log.Output.CONSOLE)
        CONSOLE = 0,
        // @@protoc_insertion_point(enum_value:Log.Output.FILE)
        FILE = 1,
    }

    impl ::protobuf::Enum for Output {
        const NAME: &'static str = "Output";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Output> {
            match value {
                0 => ::std::option::Option::Some(Output::CONSOLE),
                1 => ::std::option::Option::Some(Output::FILE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Output] = &[
            Output::CONSOLE,
            Output::FILE,
        ];
    }

    impl ::std::default::Default for Output {
        fn default() -> Self {
            Output::CONSOLE
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TunInboundSettings)
pub struct TunInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:TunInboundSettings.fd)
    pub fd: i32,
    // @@protoc_insertion_point(field:TunInboundSettings.auto)
    pub auto: bool,
    // @@protoc_insertion_point(field:TunInboundSettings.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:TunInboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:TunInboundSettings.gateway)
    pub gateway: ::std::string::String,
    // @@protoc_insertion_point(field:TunInboundSettings.netmask)
    pub netmask: ::std::string::String,
    // @@protoc_insertion_point(field:TunInboundSettings.mtu)
    pub mtu: i32,
    // @@protoc_insertion_point(field:TunInboundSettings.fake_dns_exclude)
    pub fake_dns_exclude: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:TunInboundSettings.fake_dns_include)
    pub fake_dns_include: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:TunInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TunInboundSettings {
    fn default() -> &'a TunInboundSettings {
        <TunInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TunInboundSettings {
    pub fn new() -> TunInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TunInboundSettings {
    const NAME: &'static str = "TunInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fd = is.read_int32()?;
                },
                72 => {
                    self.auto = is.read_bool()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.address = is.read_string()?;
                },
                34 => {
                    self.gateway = is.read_string()?;
                },
                42 => {
                    self.netmask = is.read_string()?;
                },
                48 => {
                    self.mtu = is.read_int32()?;
                },
                58 => {
                    self.fake_dns_exclude.push(is.read_string()?);
                },
                66 => {
                    self.fake_dns_include.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fd != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.fd);
        }
        if self.auto != false {
            my_size += 1 + 1;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if !self.gateway.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.gateway);
        }
        if !self.netmask.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.netmask);
        }
        if self.mtu != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.mtu);
        }
        for value in &self.fake_dns_exclude {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.fake_dns_include {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fd != 0 {
            os.write_int32(1, self.fd)?;
        }
        if self.auto != false {
            os.write_bool(9, self.auto)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if !self.gateway.is_empty() {
            os.write_string(4, &self.gateway)?;
        }
        if !self.netmask.is_empty() {
            os.write_string(5, &self.netmask)?;
        }
        if self.mtu != 0 {
            os.write_int32(6, self.mtu)?;
        }
        for v in &self.fake_dns_exclude {
            os.write_string(7, &v)?;
        };
        for v in &self.fake_dns_include {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TunInboundSettings {
        TunInboundSettings::new()
    }

    fn clear(&mut self) {
        self.fd = 0;
        self.auto = false;
        self.name.clear();
        self.address.clear();
        self.gateway.clear();
        self.netmask.clear();
        self.mtu = 0;
        self.fake_dns_exclude.clear();
        self.fake_dns_include.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TunInboundSettings {
        static instance: TunInboundSettings = TunInboundSettings {
            fd: 0,
            auto: false,
            name: ::std::string::String::new(),
            address: ::std::string::String::new(),
            gateway: ::std::string::String::new(),
            netmask: ::std::string::String::new(),
            mtu: 0,
            fake_dns_exclude: ::std::vec::Vec::new(),
            fake_dns_include: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CatInboundSettings)
pub struct CatInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:CatInboundSettings.network)
    pub network: ::std::string::String,
    // @@protoc_insertion_point(field:CatInboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:CatInboundSettings.port)
    pub port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:CatInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CatInboundSettings {
    fn default() -> &'a CatInboundSettings {
        <CatInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl CatInboundSettings {
    pub fn new() -> CatInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CatInboundSettings {
    const NAME: &'static str = "CatInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.network = is.read_string()?;
                },
                18 => {
                    self.address = is.read_string()?;
                },
                24 => {
                    self.port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(3, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CatInboundSettings {
        CatInboundSettings::new()
    }

    fn clear(&mut self) {
        self.network.clear();
        self.address.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CatInboundSettings {
        static instance: CatInboundSettings = CatInboundSettings {
            network: ::std::string::String::new(),
            address: ::std::string::String::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ShadowsocksInboundSettings)
pub struct ShadowsocksInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:ShadowsocksInboundSettings.method)
    pub method: ::std::string::String,
    // @@protoc_insertion_point(field:ShadowsocksInboundSettings.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ShadowsocksInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShadowsocksInboundSettings {
    fn default() -> &'a ShadowsocksInboundSettings {
        <ShadowsocksInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ShadowsocksInboundSettings {
    pub fn new() -> ShadowsocksInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ShadowsocksInboundSettings {
    const NAME: &'static str = "ShadowsocksInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method = is.read_string()?;
                },
                18 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.method);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.method.is_empty() {
            os.write_string(1, &self.method)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShadowsocksInboundSettings {
        ShadowsocksInboundSettings::new()
    }

    fn clear(&mut self) {
        self.method.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShadowsocksInboundSettings {
        static instance: ShadowsocksInboundSettings = ShadowsocksInboundSettings {
            method: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TrojanInboundSettings)
pub struct TrojanInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:TrojanInboundSettings.passwords)
    pub passwords: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:TrojanInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrojanInboundSettings {
    fn default() -> &'a TrojanInboundSettings {
        <TrojanInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TrojanInboundSettings {
    pub fn new() -> TrojanInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TrojanInboundSettings {
    const NAME: &'static str = "TrojanInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.passwords.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.passwords {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.passwords {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrojanInboundSettings {
        TrojanInboundSettings::new()
    }

    fn clear(&mut self) {
        self.passwords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrojanInboundSettings {
        static instance: TrojanInboundSettings = TrojanInboundSettings {
            passwords: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebSocketInboundSettings)
pub struct WebSocketInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:WebSocketInboundSettings.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:WebSocketInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebSocketInboundSettings {
    fn default() -> &'a WebSocketInboundSettings {
        <WebSocketInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl WebSocketInboundSettings {
    pub fn new() -> WebSocketInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WebSocketInboundSettings {
    const NAME: &'static str = "WebSocketInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebSocketInboundSettings {
        WebSocketInboundSettings::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebSocketInboundSettings {
        static instance: WebSocketInboundSettings = WebSocketInboundSettings {
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AMuxInboundSettings)
pub struct AMuxInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:AMuxInboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:AMuxInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AMuxInboundSettings {
    fn default() -> &'a AMuxInboundSettings {
        <AMuxInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl AMuxInboundSettings {
    pub fn new() -> AMuxInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AMuxInboundSettings {
    const NAME: &'static str = "AMuxInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AMuxInboundSettings {
        AMuxInboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AMuxInboundSettings {
        static instance: AMuxInboundSettings = AMuxInboundSettings {
            actors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:QuicInboundSettings)
pub struct QuicInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:QuicInboundSettings.certificate)
    pub certificate: ::std::string::String,
    // @@protoc_insertion_point(field:QuicInboundSettings.certificate_key)
    pub certificate_key: ::std::string::String,
    // @@protoc_insertion_point(field:QuicInboundSettings.alpn)
    pub alpn: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:QuicInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuicInboundSettings {
    fn default() -> &'a QuicInboundSettings {
        <QuicInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl QuicInboundSettings {
    pub fn new() -> QuicInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QuicInboundSettings {
    const NAME: &'static str = "QuicInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.certificate = is.read_string()?;
                },
                18 => {
                    self.certificate_key = is.read_string()?;
                },
                26 => {
                    self.alpn.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.certificate);
        }
        if !self.certificate_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.certificate_key);
        }
        for value in &self.alpn {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.certificate.is_empty() {
            os.write_string(1, &self.certificate)?;
        }
        if !self.certificate_key.is_empty() {
            os.write_string(2, &self.certificate_key)?;
        }
        for v in &self.alpn {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuicInboundSettings {
        QuicInboundSettings::new()
    }

    fn clear(&mut self) {
        self.certificate.clear();
        self.certificate_key.clear();
        self.alpn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuicInboundSettings {
        static instance: QuicInboundSettings = QuicInboundSettings {
            certificate: ::std::string::String::new(),
            certificate_key: ::std::string::String::new(),
            alpn: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TlsInboundSettings)
pub struct TlsInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:TlsInboundSettings.certificate)
    pub certificate: ::std::string::String,
    // @@protoc_insertion_point(field:TlsInboundSettings.certificate_key)
    pub certificate_key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TlsInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TlsInboundSettings {
    fn default() -> &'a TlsInboundSettings {
        <TlsInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TlsInboundSettings {
    pub fn new() -> TlsInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TlsInboundSettings {
    const NAME: &'static str = "TlsInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.certificate = is.read_string()?;
                },
                18 => {
                    self.certificate_key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.certificate);
        }
        if !self.certificate_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.certificate_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.certificate.is_empty() {
            os.write_string(1, &self.certificate)?;
        }
        if !self.certificate_key.is_empty() {
            os.write_string(2, &self.certificate_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TlsInboundSettings {
        TlsInboundSettings::new()
    }

    fn clear(&mut self) {
        self.certificate.clear();
        self.certificate_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TlsInboundSettings {
        static instance: TlsInboundSettings = TlsInboundSettings {
            certificate: ::std::string::String::new(),
            certificate_key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ChainInboundSettings)
pub struct ChainInboundSettings {
    // message fields
    // @@protoc_insertion_point(field:ChainInboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ChainInboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChainInboundSettings {
    fn default() -> &'a ChainInboundSettings {
        <ChainInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ChainInboundSettings {
    pub fn new() -> ChainInboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChainInboundSettings {
    const NAME: &'static str = "ChainInboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChainInboundSettings {
        ChainInboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChainInboundSettings {
        static instance: ChainInboundSettings = ChainInboundSettings {
            actors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Inbound)
pub struct Inbound {
    // message fields
    // @@protoc_insertion_point(field:Inbound.tag)
    pub tag: ::std::string::String,
    // @@protoc_insertion_point(field:Inbound.protocol)
    pub protocol: ::std::string::String,
    // @@protoc_insertion_point(field:Inbound.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:Inbound.port)
    pub port: u32,
    // @@protoc_insertion_point(field:Inbound.settings)
    pub settings: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:Inbound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Inbound {
    fn default() -> &'a Inbound {
        <Inbound as ::protobuf::Message>::default_instance()
    }
}

impl Inbound {
    pub fn new() -> Inbound {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Inbound {
    const NAME: &'static str = "Inbound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = is.read_string()?;
                },
                18 => {
                    self.protocol = is.read_string()?;
                },
                26 => {
                    self.address = is.read_string()?;
                },
                32 => {
                    self.port = is.read_uint32()?;
                },
                42 => {
                    self.settings = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.port);
        }
        if !self.settings.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.settings);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(4, self.port)?;
        }
        if !self.settings.is_empty() {
            os.write_bytes(5, &self.settings)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Inbound {
        Inbound::new()
    }

    fn clear(&mut self) {
        self.tag.clear();
        self.protocol.clear();
        self.address.clear();
        self.port = 0;
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Inbound {
        static instance: Inbound = Inbound {
            tag: ::std::string::String::new(),
            protocol: ::std::string::String::new(),
            address: ::std::string::String::new(),
            port: 0,
            settings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:RedirectOutboundSettings)
pub struct RedirectOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:RedirectOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:RedirectOutboundSettings.port)
    pub port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:RedirectOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RedirectOutboundSettings {
    fn default() -> &'a RedirectOutboundSettings {
        <RedirectOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl RedirectOutboundSettings {
    pub fn new() -> RedirectOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RedirectOutboundSettings {
    const NAME: &'static str = "RedirectOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RedirectOutboundSettings {
        RedirectOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RedirectOutboundSettings {
        static instance: RedirectOutboundSettings = RedirectOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SocksOutboundSettings)
pub struct SocksOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:SocksOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:SocksOutboundSettings.port)
    pub port: u32,
    // @@protoc_insertion_point(field:SocksOutboundSettings.username)
    pub username: ::std::string::String,
    // @@protoc_insertion_point(field:SocksOutboundSettings.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:SocksOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SocksOutboundSettings {
    fn default() -> &'a SocksOutboundSettings {
        <SocksOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl SocksOutboundSettings {
    pub fn new() -> SocksOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SocksOutboundSettings {
    const NAME: &'static str = "SocksOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.username = is.read_string()?;
                },
                34 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.username.is_empty() {
            os.write_string(3, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(4, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SocksOutboundSettings {
        SocksOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.username.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SocksOutboundSettings {
        static instance: SocksOutboundSettings = SocksOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            username: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ShadowsocksOutboundSettings)
pub struct ShadowsocksOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:ShadowsocksOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:ShadowsocksOutboundSettings.port)
    pub port: u32,
    // @@protoc_insertion_point(field:ShadowsocksOutboundSettings.method)
    pub method: ::std::string::String,
    // @@protoc_insertion_point(field:ShadowsocksOutboundSettings.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ShadowsocksOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ShadowsocksOutboundSettings {
    fn default() -> &'a ShadowsocksOutboundSettings {
        <ShadowsocksOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ShadowsocksOutboundSettings {
    pub fn new() -> ShadowsocksOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ShadowsocksOutboundSettings {
    const NAME: &'static str = "ShadowsocksOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.method = is.read_string()?;
                },
                34 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.method);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.method.is_empty() {
            os.write_string(3, &self.method)?;
        }
        if !self.password.is_empty() {
            os.write_string(4, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ShadowsocksOutboundSettings {
        ShadowsocksOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.method.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ShadowsocksOutboundSettings {
        static instance: ShadowsocksOutboundSettings = ShadowsocksOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            method: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ObfsOutboundSettings)
pub struct ObfsOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:ObfsOutboundSettings.method)
    pub method: ::std::string::String,
    // @@protoc_insertion_point(field:ObfsOutboundSettings.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:ObfsOutboundSettings.path)
    pub path: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ObfsOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObfsOutboundSettings {
    fn default() -> &'a ObfsOutboundSettings {
        <ObfsOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ObfsOutboundSettings {
    pub fn new() -> ObfsOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ObfsOutboundSettings {
    const NAME: &'static str = "ObfsOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.method = is.read_string()?;
                },
                18 => {
                    self.host = is.read_string()?;
                },
                26 => {
                    self.path = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.method);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.method.is_empty() {
            os.write_string(1, &self.method)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObfsOutboundSettings {
        ObfsOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.method.clear();
        self.host.clear();
        self.path.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObfsOutboundSettings {
        static instance: ObfsOutboundSettings = ObfsOutboundSettings {
            method: ::std::string::String::new(),
            host: ::std::string::String::new(),
            path: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TrojanOutboundSettings)
pub struct TrojanOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:TrojanOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:TrojanOutboundSettings.port)
    pub port: u32,
    // @@protoc_insertion_point(field:TrojanOutboundSettings.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:TrojanOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrojanOutboundSettings {
    fn default() -> &'a TrojanOutboundSettings {
        <TrojanOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TrojanOutboundSettings {
    pub fn new() -> TrojanOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TrojanOutboundSettings {
    const NAME: &'static str = "TrojanOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrojanOutboundSettings {
        TrojanOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrojanOutboundSettings {
        static instance: TrojanOutboundSettings = TrojanOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TlsOutboundSettings)
pub struct TlsOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:TlsOutboundSettings.server_name)
    pub server_name: ::std::string::String,
    // @@protoc_insertion_point(field:TlsOutboundSettings.alpn)
    pub alpn: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:TlsOutboundSettings.certificate)
    pub certificate: ::std::string::String,
    // @@protoc_insertion_point(field:TlsOutboundSettings.insecure)
    pub insecure: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TlsOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TlsOutboundSettings {
    fn default() -> &'a TlsOutboundSettings {
        <TlsOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TlsOutboundSettings {
    pub fn new() -> TlsOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TlsOutboundSettings {
    const NAME: &'static str = "TlsOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.server_name = is.read_string()?;
                },
                18 => {
                    self.alpn.push(is.read_string()?);
                },
                26 => {
                    self.certificate = is.read_string()?;
                },
                32 => {
                    self.insecure = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.server_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.server_name);
        }
        for value in &self.alpn {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.certificate);
        }
        if self.insecure != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.server_name.is_empty() {
            os.write_string(1, &self.server_name)?;
        }
        for v in &self.alpn {
            os.write_string(2, &v)?;
        };
        if !self.certificate.is_empty() {
            os.write_string(3, &self.certificate)?;
        }
        if self.insecure != false {
            os.write_bool(4, self.insecure)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TlsOutboundSettings {
        TlsOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.server_name.clear();
        self.alpn.clear();
        self.certificate.clear();
        self.insecure = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TlsOutboundSettings {
        static instance: TlsOutboundSettings = TlsOutboundSettings {
            server_name: ::std::string::String::new(),
            alpn: ::std::vec::Vec::new(),
            certificate: ::std::string::String::new(),
            insecure: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WebSocketOutboundSettings)
pub struct WebSocketOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:WebSocketOutboundSettings.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:WebSocketOutboundSettings.headers)
    pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:WebSocketOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebSocketOutboundSettings {
    fn default() -> &'a WebSocketOutboundSettings {
        <WebSocketOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl WebSocketOutboundSettings {
    pub fn new() -> WebSocketOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WebSocketOutboundSettings {
    const NAME: &'static str = "WebSocketOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.headers.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        for (k, v) in &self.headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        for (k, v) in &self.headers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebSocketOutboundSettings {
        WebSocketOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.headers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebSocketOutboundSettings {
        static instance: ::protobuf::rt::Lazy<WebSocketOutboundSettings> = ::protobuf::rt::Lazy::new();
        instance.get(WebSocketOutboundSettings::new)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TryAllOutboundSettings)
pub struct TryAllOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:TryAllOutboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:TryAllOutboundSettings.delay_base)
    pub delay_base: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TryAllOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TryAllOutboundSettings {
    fn default() -> &'a TryAllOutboundSettings {
        <TryAllOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TryAllOutboundSettings {
    pub fn new() -> TryAllOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TryAllOutboundSettings {
    const NAME: &'static str = "TryAllOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                16 => {
                    self.delay_base = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.delay_base != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.delay_base);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.delay_base != 0 {
            os.write_uint32(2, self.delay_base)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TryAllOutboundSettings {
        TryAllOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.delay_base = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TryAllOutboundSettings {
        static instance: TryAllOutboundSettings = TryAllOutboundSettings {
            actors: ::std::vec::Vec::new(),
            delay_base: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StaticOutboundSettings)
pub struct StaticOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:StaticOutboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:StaticOutboundSettings.method)
    pub method: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:StaticOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StaticOutboundSettings {
    fn default() -> &'a StaticOutboundSettings {
        <StaticOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl StaticOutboundSettings {
    pub fn new() -> StaticOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StaticOutboundSettings {
    const NAME: &'static str = "StaticOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                18 => {
                    self.method = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.method);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if !self.method.is_empty() {
            os.write_string(2, &self.method)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StaticOutboundSettings {
        StaticOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.method.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StaticOutboundSettings {
        static instance: StaticOutboundSettings = StaticOutboundSettings {
            actors: ::std::vec::Vec::new(),
            method: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AMuxOutboundSettings)
pub struct AMuxOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:AMuxOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:AMuxOutboundSettings.port)
    pub port: u32,
    // @@protoc_insertion_point(field:AMuxOutboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:AMuxOutboundSettings.max_accepts)
    pub max_accepts: u32,
    // @@protoc_insertion_point(field:AMuxOutboundSettings.concurrency)
    pub concurrency: u32,
    // special fields
    // @@protoc_insertion_point(special_field:AMuxOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AMuxOutboundSettings {
    fn default() -> &'a AMuxOutboundSettings {
        <AMuxOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl AMuxOutboundSettings {
    pub fn new() -> AMuxOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AMuxOutboundSettings {
    const NAME: &'static str = "AMuxOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.actors.push(is.read_string()?);
                },
                32 => {
                    self.max_accepts = is.read_uint32()?;
                },
                40 => {
                    self.concurrency = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.max_accepts != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.max_accepts);
        }
        if self.concurrency != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.concurrency);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        for v in &self.actors {
            os.write_string(3, &v)?;
        };
        if self.max_accepts != 0 {
            os.write_uint32(4, self.max_accepts)?;
        }
        if self.concurrency != 0 {
            os.write_uint32(5, self.concurrency)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AMuxOutboundSettings {
        AMuxOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.actors.clear();
        self.max_accepts = 0;
        self.concurrency = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AMuxOutboundSettings {
        static instance: AMuxOutboundSettings = AMuxOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            actors: ::std::vec::Vec::new(),
            max_accepts: 0,
            concurrency: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:QuicOutboundSettings)
pub struct QuicOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:QuicOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:QuicOutboundSettings.port)
    pub port: u32,
    // @@protoc_insertion_point(field:QuicOutboundSettings.server_name)
    pub server_name: ::std::string::String,
    // @@protoc_insertion_point(field:QuicOutboundSettings.certificate)
    pub certificate: ::std::string::String,
    // @@protoc_insertion_point(field:QuicOutboundSettings.alpn)
    pub alpn: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:QuicOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuicOutboundSettings {
    fn default() -> &'a QuicOutboundSettings {
        <QuicOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl QuicOutboundSettings {
    pub fn new() -> QuicOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for QuicOutboundSettings {
    const NAME: &'static str = "QuicOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.server_name = is.read_string()?;
                },
                34 => {
                    self.certificate = is.read_string()?;
                },
                42 => {
                    self.alpn.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if !self.server_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.server_name);
        }
        if !self.certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.certificate);
        }
        for value in &self.alpn {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.server_name.is_empty() {
            os.write_string(3, &self.server_name)?;
        }
        if !self.certificate.is_empty() {
            os.write_string(4, &self.certificate)?;
        }
        for v in &self.alpn {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuicOutboundSettings {
        QuicOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.server_name.clear();
        self.certificate.clear();
        self.alpn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuicOutboundSettings {
        static instance: QuicOutboundSettings = QuicOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            server_name: ::std::string::String::new(),
            certificate: ::std::string::String::new(),
            alpn: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:VMessOutboundSettings)
pub struct VMessOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:VMessOutboundSettings.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:VMessOutboundSettings.port)
    pub port: u32,
    // @@protoc_insertion_point(field:VMessOutboundSettings.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:VMessOutboundSettings.security)
    pub security: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:VMessOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VMessOutboundSettings {
    fn default() -> &'a VMessOutboundSettings {
        <VMessOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl VMessOutboundSettings {
    pub fn new() -> VMessOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VMessOutboundSettings {
    const NAME: &'static str = "VMessOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                16 => {
                    self.port = is.read_uint32()?;
                },
                26 => {
                    self.uuid = is.read_string()?;
                },
                34 => {
                    self.security = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.port);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uuid);
        }
        if !self.security.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.security);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(3, &self.uuid)?;
        }
        if !self.security.is_empty() {
            os.write_string(4, &self.security)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VMessOutboundSettings {
        VMessOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.uuid.clear();
        self.security.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VMessOutboundSettings {
        static instance: VMessOutboundSettings = VMessOutboundSettings {
            address: ::std::string::String::new(),
            port: 0,
            uuid: ::std::string::String::new(),
            security: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ChainOutboundSettings)
pub struct ChainOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:ChainOutboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ChainOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChainOutboundSettings {
    fn default() -> &'a ChainOutboundSettings {
        <ChainOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ChainOutboundSettings {
    pub fn new() -> ChainOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChainOutboundSettings {
    const NAME: &'static str = "ChainOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChainOutboundSettings {
        ChainOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChainOutboundSettings {
        static instance: ChainOutboundSettings = ChainOutboundSettings {
            actors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:FailOverOutboundSettings)
pub struct FailOverOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:FailOverOutboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.fail_timeout)
    pub fail_timeout: u32,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.health_check)
    pub health_check: bool,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.check_interval)
    pub check_interval: u32,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.failover)
    pub failover: bool,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.fallback_cache)
    pub fallback_cache: bool,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.cache_size)
    pub cache_size: u32,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.cache_timeout)
    pub cache_timeout: u32,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.last_resort)
    pub last_resort: ::std::string::String,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.health_check_timeout)
    pub health_check_timeout: u32,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.health_check_delay)
    pub health_check_delay: u32,
    // @@protoc_insertion_point(field:FailOverOutboundSettings.health_check_active)
    pub health_check_active: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FailOverOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FailOverOutboundSettings {
    fn default() -> &'a FailOverOutboundSettings {
        <FailOverOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl FailOverOutboundSettings {
    pub fn new() -> FailOverOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FailOverOutboundSettings {
    const NAME: &'static str = "FailOverOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                16 => {
                    self.fail_timeout = is.read_uint32()?;
                },
                24 => {
                    self.health_check = is.read_bool()?;
                },
                32 => {
                    self.check_interval = is.read_uint32()?;
                },
                40 => {
                    self.failover = is.read_bool()?;
                },
                48 => {
                    self.fallback_cache = is.read_bool()?;
                },
                56 => {
                    self.cache_size = is.read_uint32()?;
                },
                64 => {
                    self.cache_timeout = is.read_uint32()?;
                },
                74 => {
                    self.last_resort = is.read_string()?;
                },
                80 => {
                    self.health_check_timeout = is.read_uint32()?;
                },
                88 => {
                    self.health_check_delay = is.read_uint32()?;
                },
                96 => {
                    self.health_check_active = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.fail_timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.fail_timeout);
        }
        if self.health_check != false {
            my_size += 1 + 1;
        }
        if self.check_interval != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.check_interval);
        }
        if self.failover != false {
            my_size += 1 + 1;
        }
        if self.fallback_cache != false {
            my_size += 1 + 1;
        }
        if self.cache_size != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.cache_size);
        }
        if self.cache_timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.cache_timeout);
        }
        if !self.last_resort.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.last_resort);
        }
        if self.health_check_timeout != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.health_check_timeout);
        }
        if self.health_check_delay != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.health_check_delay);
        }
        if self.health_check_active != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.health_check_active);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.fail_timeout != 0 {
            os.write_uint32(2, self.fail_timeout)?;
        }
        if self.health_check != false {
            os.write_bool(3, self.health_check)?;
        }
        if self.check_interval != 0 {
            os.write_uint32(4, self.check_interval)?;
        }
        if self.failover != false {
            os.write_bool(5, self.failover)?;
        }
        if self.fallback_cache != false {
            os.write_bool(6, self.fallback_cache)?;
        }
        if self.cache_size != 0 {
            os.write_uint32(7, self.cache_size)?;
        }
        if self.cache_timeout != 0 {
            os.write_uint32(8, self.cache_timeout)?;
        }
        if !self.last_resort.is_empty() {
            os.write_string(9, &self.last_resort)?;
        }
        if self.health_check_timeout != 0 {
            os.write_uint32(10, self.health_check_timeout)?;
        }
        if self.health_check_delay != 0 {
            os.write_uint32(11, self.health_check_delay)?;
        }
        if self.health_check_active != 0 {
            os.write_uint32(12, self.health_check_active)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FailOverOutboundSettings {
        FailOverOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.fail_timeout = 0;
        self.health_check = false;
        self.check_interval = 0;
        self.failover = false;
        self.fallback_cache = false;
        self.cache_size = 0;
        self.cache_timeout = 0;
        self.last_resort.clear();
        self.health_check_timeout = 0;
        self.health_check_delay = 0;
        self.health_check_active = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FailOverOutboundSettings {
        static instance: FailOverOutboundSettings = FailOverOutboundSettings {
            actors: ::std::vec::Vec::new(),
            fail_timeout: 0,
            health_check: false,
            check_interval: 0,
            failover: false,
            fallback_cache: false,
            cache_size: 0,
            cache_timeout: 0,
            last_resort: ::std::string::String::new(),
            health_check_timeout: 0,
            health_check_delay: 0,
            health_check_active: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SelectOutboundSettings)
pub struct SelectOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:SelectOutboundSettings.actors)
    pub actors: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SelectOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectOutboundSettings {
    fn default() -> &'a SelectOutboundSettings {
        <SelectOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl SelectOutboundSettings {
    pub fn new() -> SelectOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SelectOutboundSettings {
    const NAME: &'static str = "SelectOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actors.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectOutboundSettings {
        SelectOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.actors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectOutboundSettings {
        static instance: SelectOutboundSettings = SelectOutboundSettings {
            actors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PluginOutboundSettings)
pub struct PluginOutboundSettings {
    // message fields
    // @@protoc_insertion_point(field:PluginOutboundSettings.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:PluginOutboundSettings.args)
    pub args: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:PluginOutboundSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PluginOutboundSettings {
    fn default() -> &'a PluginOutboundSettings {
        <PluginOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl PluginOutboundSettings {
    pub fn new() -> PluginOutboundSettings {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PluginOutboundSettings {
    const NAME: &'static str = "PluginOutboundSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.path = is.read_string()?;
                },
                18 => {
                    self.args = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.args.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.args);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.args.is_empty() {
            os.write_string(2, &self.args)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PluginOutboundSettings {
        PluginOutboundSettings::new()
    }

    fn clear(&mut self) {
        self.path.clear();
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PluginOutboundSettings {
        static instance: PluginOutboundSettings = PluginOutboundSettings {
            path: ::std::string::String::new(),
            args: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Outbound)
pub struct Outbound {
    // message fields
    // @@protoc_insertion_point(field:Outbound.tag)
    pub tag: ::std::string::String,
    // @@protoc_insertion_point(field:Outbound.protocol)
    pub protocol: ::std::string::String,
    // @@protoc_insertion_point(field:Outbound.settings)
    pub settings: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:Outbound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Outbound {
    fn default() -> &'a Outbound {
        <Outbound as ::protobuf::Message>::default_instance()
    }
}

impl Outbound {
    pub fn new() -> Outbound {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Outbound {
    const NAME: &'static str = "Outbound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = is.read_string()?;
                },
                18 => {
                    self.protocol = is.read_string()?;
                },
                34 => {
                    self.settings = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        if !self.settings.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.settings);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        if !self.settings.is_empty() {
            os.write_bytes(4, &self.settings)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Outbound {
        Outbound::new()
    }

    fn clear(&mut self) {
        self.tag.clear();
        self.protocol.clear();
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Outbound {
        static instance: Outbound = Outbound {
            tag: ::std::string::String::new(),
            protocol: ::std::string::String::new(),
            settings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Router)
pub struct Router {
    // message fields
    // @@protoc_insertion_point(field:Router.rules)
    pub rules: ::std::vec::Vec<router::Rule>,
    // @@protoc_insertion_point(field:Router.domain_resolve)
    pub domain_resolve: bool,
    // special fields
    // @@protoc_insertion_point(special_field:Router.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Router {
    fn default() -> &'a Router {
        <Router as ::protobuf::Message>::default_instance()
    }
}

impl Router {
    pub fn new() -> Router {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Router {
    const NAME: &'static str = "Router";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rules.push(is.read_message()?);
                },
                16 => {
                    self.domain_resolve = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.domain_resolve != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.domain_resolve != false {
            os.write_bool(2, self.domain_resolve)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Router {
        Router::new()
    }

    fn clear(&mut self) {
        self.rules.clear();
        self.domain_resolve = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Router {
        static instance: Router = Router {
            rules: ::std::vec::Vec::new(),
            domain_resolve: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Router`
pub mod router {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:Router.Rule)
    pub struct Rule {
        // message fields
        // @@protoc_insertion_point(field:Router.Rule.target_tag)
        pub target_tag: ::std::string::String,
        // @@protoc_insertion_point(field:Router.Rule.domains)
        pub domains: ::std::vec::Vec<rule::Domain>,
        // @@protoc_insertion_point(field:Router.Rule.ip_cidrs)
        pub ip_cidrs: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:Router.Rule.mmdbs)
        pub mmdbs: ::std::vec::Vec<rule::Mmdb>,
        // @@protoc_insertion_point(field:Router.Rule.port_ranges)
        pub port_ranges: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:Router.Rule.networks)
        pub networks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:Router.Rule.inbound_tags)
        pub inbound_tags: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:Router.Rule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Rule {
        fn default() -> &'a Rule {
            <Rule as ::protobuf::Message>::default_instance()
        }
    }

    impl Rule {
        pub fn new() -> Rule {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Rule {
        const NAME: &'static str = "Rule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.target_tag = is.read_string()?;
                    },
                    18 => {
                        self.domains.push(is.read_message()?);
                    },
                    26 => {
                        self.ip_cidrs.push(is.read_string()?);
                    },
                    34 => {
                        self.mmdbs.push(is.read_message()?);
                    },
                    42 => {
                        self.port_ranges.push(is.read_string()?);
                    },
                    50 => {
                        self.networks.push(is.read_string()?);
                    },
                    58 => {
                        self.inbound_tags.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.target_tag.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.target_tag);
            }
            for value in &self.domains {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.ip_cidrs {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.mmdbs {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.port_ranges {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.networks {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            for value in &self.inbound_tags {
                my_size += ::protobuf::rt::string_size(7, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.target_tag.is_empty() {
                os.write_string(1, &self.target_tag)?;
            }
            for v in &self.domains {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.ip_cidrs {
                os.write_string(3, &v)?;
            };
            for v in &self.mmdbs {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            for v in &self.port_ranges {
                os.write_string(5, &v)?;
            };
            for v in &self.networks {
                os.write_string(6, &v)?;
            };
            for v in &self.inbound_tags {
                os.write_string(7, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Rule {
            Rule::new()
        }

        fn clear(&mut self) {
            self.target_tag.clear();
            self.domains.clear();
            self.ip_cidrs.clear();
            self.mmdbs.clear();
            self.port_ranges.clear();
            self.networks.clear();
            self.inbound_tags.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Rule {
            static instance: Rule = Rule {
                target_tag: ::std::string::String::new(),
                domains: ::std::vec::Vec::new(),
                ip_cidrs: ::std::vec::Vec::new(),
                mmdbs: ::std::vec::Vec::new(),
                port_ranges: ::std::vec::Vec::new(),
                networks: ::std::vec::Vec::new(),
                inbound_tags: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Rule`
    pub mod rule {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:Router.Rule.Domain)
        pub struct Domain {
            // message fields
            // @@protoc_insertion_point(field:Router.Rule.Domain.type)
            pub type_: ::protobuf::EnumOrUnknown<domain::Type>,
            // @@protoc_insertion_point(field:Router.Rule.Domain.value)
            pub value: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Router.Rule.Domain.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Domain {
            fn default() -> &'a Domain {
                <Domain as ::protobuf::Message>::default_instance()
            }
        }

        impl Domain {
            pub fn new() -> Domain {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for Domain {
            const NAME: &'static str = "Domain";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.value = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.type_ != ::protobuf::EnumOrUnknown::new(domain::Type::PLAIN) {
                    my_size += ::protobuf::rt::int32_size(1, self.type_.value());
                }
                if !self.value.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.type_ != ::protobuf::EnumOrUnknown::new(domain::Type::PLAIN) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
                }
                if !self.value.is_empty() {
                    os.write_string(2, &self.value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Domain {
                Domain::new()
            }

            fn clear(&mut self) {
                self.type_ = ::protobuf::EnumOrUnknown::new(domain::Type::PLAIN);
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Domain {
                static instance: Domain = Domain {
                    type_: ::protobuf::EnumOrUnknown::from_i32(0),
                    value: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `Domain`
        pub mod domain {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:Router.Rule.Domain.Type)
            pub enum Type {
                // @@protoc_insertion_point(enum_value:Router.Rule.Domain.Type.PLAIN)
                PLAIN = 0,
                // @@protoc_insertion_point(enum_value:Router.Rule.Domain.Type.DOMAIN)
                DOMAIN = 1,
                // @@protoc_insertion_point(enum_value:Router.Rule.Domain.Type.FULL)
                FULL = 2,
            }

            impl ::protobuf::Enum for Type {
                const NAME: &'static str = "Type";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<Type> {
                    match value {
                        0 => ::std::option::Option::Some(Type::PLAIN),
                        1 => ::std::option::Option::Some(Type::DOMAIN),
                        2 => ::std::option::Option::Some(Type::FULL),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [Type] = &[
                    Type::PLAIN,
                    Type::DOMAIN,
                    Type::FULL,
                ];
            }

            impl ::std::default::Default for Type {
                fn default() -> Self {
                    Type::PLAIN
                }
            }

        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:Router.Rule.Mmdb)
        pub struct Mmdb {
            // message fields
            // @@protoc_insertion_point(field:Router.Rule.Mmdb.file)
            pub file: ::std::string::String,
            // @@protoc_insertion_point(field:Router.Rule.Mmdb.country_code)
            pub country_code: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:Router.Rule.Mmdb.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Mmdb {
            fn default() -> &'a Mmdb {
                <Mmdb as ::protobuf::Message>::default_instance()
            }
        }

        impl Mmdb {
            pub fn new() -> Mmdb {
                ::std::default::Default::default()
            }
        }

        impl ::protobuf::Message for Mmdb {
            const NAME: &'static str = "Mmdb";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.file = is.read_string()?;
                        },
                        18 => {
                            self.country_code = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.file.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.file);
                }
                if !self.country_code.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.country_code);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.file.is_empty() {
                    os.write_string(1, &self.file)?;
                }
                if !self.country_code.is_empty() {
                    os.write_string(2, &self.country_code)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Mmdb {
                Mmdb::new()
            }

            fn clear(&mut self) {
                self.file.clear();
                self.country_code.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Mmdb {
                static instance: Mmdb = Mmdb {
                    file: ::std::string::String::new(),
                    country_code: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Config)
pub struct Config {
    // message fields
    // @@protoc_insertion_point(field:Config.log)
    pub log: ::protobuf::MessageField<Log>,
    // @@protoc_insertion_point(field:Config.inbounds)
    pub inbounds: ::std::vec::Vec<Inbound>,
    // @@protoc_insertion_point(field:Config.outbounds)
    pub outbounds: ::std::vec::Vec<Outbound>,
    // @@protoc_insertion_point(field:Config.router)
    pub router: ::protobuf::MessageField<Router>,
    // @@protoc_insertion_point(field:Config.dns)
    pub dns: ::protobuf::MessageField<Dns>,
    // special fields
    // @@protoc_insertion_point(special_field:Config.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Config {
    const NAME: &'static str = "Config";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.log)?;
                },
                18 => {
                    self.inbounds.push(is.read_message()?);
                },
                26 => {
                    self.outbounds.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.router)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dns)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.log.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.inbounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.outbounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.router.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dns.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.log.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.inbounds {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.outbounds {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.router.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.dns.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Config {
        Config::new()
    }

    fn clear(&mut self) {
        self.log.clear();
        self.inbounds.clear();
        self.outbounds.clear();
        self.router.clear();
        self.dns.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Config {
        static instance: Config = Config {
            log: ::protobuf::MessageField::none(),
            inbounds: ::std::vec::Vec::new(),
            outbounds: ::std::vec::Vec::new(),
            router: ::protobuf::MessageField::none(),
            dns: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}
