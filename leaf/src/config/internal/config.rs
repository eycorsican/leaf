// This file is generated by rust-protobuf 2.22.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/config/internal/config.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_22_1;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Api {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Api {
    fn default() -> &'a Api {
        <Api as ::protobuf::Message>::default_instance()
    }
}

impl Api {
    pub fn new() -> Api {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
}

impl ::protobuf::Message for Api {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Api {
        Api::new()
    }

    fn default_instance() -> &'static Api {
        static instance: ::protobuf::rt::LazyV2<Api> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Api::new)
    }
}

impl ::protobuf::Clear for Api {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Api {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dns {
    // message fields
    pub servers: ::protobuf::RepeatedField<::std::string::String>,
    pub bind: ::std::string::String,
    pub hosts: ::std::collections::HashMap<::std::string::String, Dns_Ips>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dns {
    fn default() -> &'a Dns {
        <Dns as ::protobuf::Message>::default_instance()
    }
}

impl Dns {
    pub fn new() -> Dns {
        ::std::default::Default::default()
    }

    // repeated string servers = 1;


    pub fn get_servers(&self) -> &[::std::string::String] {
        &self.servers
    }

    // string bind = 2;


    pub fn get_bind(&self) -> &str {
        &self.bind
    }

    // repeated .Dns.HostsEntry hosts = 3;


    pub fn get_hosts(&self) -> &::std::collections::HashMap<::std::string::String, Dns_Ips> {
        &self.hosts
    }
}

impl ::protobuf::Message for Dns {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.servers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bind)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Dns_Ips>>(wire_type, is, &mut self.hosts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.bind.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bind);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Dns_Ips>>(3, &self.hosts);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_string(1, &v)?;
        };
        if !self.bind.is_empty() {
            os.write_string(2, &self.bind)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Dns_Ips>>(3, &self.hosts, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dns {
        Dns::new()
    }

    fn default_instance() -> &'static Dns {
        static instance: ::protobuf::rt::LazyV2<Dns> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dns::new)
    }
}

impl ::protobuf::Clear for Dns {
    fn clear(&mut self) {
        self.servers.clear();
        self.bind.clear();
        self.hosts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Dns {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Dns_Ips {
    // message fields
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dns_Ips {
    fn default() -> &'a Dns_Ips {
        <Dns_Ips as ::protobuf::Message>::default_instance()
    }
}

impl Dns_Ips {
    pub fn new() -> Dns_Ips {
        ::std::default::Default::default()
    }

    // repeated string values = 1;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
}

impl ::protobuf::Message for Dns_Ips {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dns_Ips {
        Dns_Ips::new()
    }

    fn default_instance() -> &'static Dns_Ips {
        static instance: ::protobuf::rt::LazyV2<Dns_Ips> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dns_Ips::new)
    }
}

impl ::protobuf::Clear for Dns_Ips {
    fn clear(&mut self) {
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Dns_Ips {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Log {
    // message fields
    pub level: Log_Level,
    pub output: Log_Output,
    pub output_file: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }

    // .Log.Level level = 1;


    pub fn get_level(&self) -> Log_Level {
        self.level
    }

    // .Log.Output output = 2;


    pub fn get_output(&self) -> Log_Output {
        self.output
    }

    // string output_file = 3;


    pub fn get_output_file(&self) -> &str {
        &self.output_file
    }
}

impl ::protobuf::Message for Log {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.output, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output_file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != Log_Level::TRACE {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if self.output != Log_Output::CONSOLE {
            my_size += ::protobuf::rt::enum_size(2, self.output);
        }
        if !self.output_file.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.output_file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != Log_Level::TRACE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if self.output != Log_Output::CONSOLE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.output))?;
        }
        if !self.output_file.is_empty() {
            os.write_string(3, &self.output_file)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Log {
        Log::new()
    }

    fn default_instance() -> &'static Log {
        static instance: ::protobuf::rt::LazyV2<Log> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Log::new)
    }
}

impl ::protobuf::Clear for Log {
    fn clear(&mut self) {
        self.level = Log_Level::TRACE;
        self.output = Log_Output::CONSOLE;
        self.output_file.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Log {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Log_Level {
    TRACE = 0,
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    ERROR = 4,
}

impl ::protobuf::ProtobufEnum for Log_Level {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Log_Level> {
        match value {
            0 => ::std::option::Option::Some(Log_Level::TRACE),
            1 => ::std::option::Option::Some(Log_Level::DEBUG),
            2 => ::std::option::Option::Some(Log_Level::INFO),
            3 => ::std::option::Option::Some(Log_Level::WARN),
            4 => ::std::option::Option::Some(Log_Level::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Log_Level] = &[
            Log_Level::TRACE,
            Log_Level::DEBUG,
            Log_Level::INFO,
            Log_Level::WARN,
            Log_Level::ERROR,
        ];
        values
    }
}

impl ::std::marker::Copy for Log_Level {
}

impl ::std::default::Default for Log_Level {
    fn default() -> Self {
        Log_Level::TRACE
    }
}

impl ::protobuf::reflect::ProtobufValue for Log_Level {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Log_Output {
    CONSOLE = 0,
    FILE = 1,
}

impl ::protobuf::ProtobufEnum for Log_Output {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Log_Output> {
        match value {
            0 => ::std::option::Option::Some(Log_Output::CONSOLE),
            1 => ::std::option::Option::Some(Log_Output::FILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Log_Output] = &[
            Log_Output::CONSOLE,
            Log_Output::FILE,
        ];
        values
    }
}

impl ::std::marker::Copy for Log_Output {
}

impl ::std::default::Default for Log_Output {
    fn default() -> Self {
        Log_Output::CONSOLE
    }
}

impl ::protobuf::reflect::ProtobufValue for Log_Output {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TunInboundSettings {
    // message fields
    pub fd: i32,
    pub auto: bool,
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    pub gateway: ::std::string::String,
    pub netmask: ::std::string::String,
    pub mtu: i32,
    pub fake_dns_exclude: ::protobuf::RepeatedField<::std::string::String>,
    pub fake_dns_include: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TunInboundSettings {
    fn default() -> &'a TunInboundSettings {
        <TunInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TunInboundSettings {
    pub fn new() -> TunInboundSettings {
        ::std::default::Default::default()
    }

    // int32 fd = 1;


    pub fn get_fd(&self) -> i32 {
        self.fd
    }

    // bool auto = 9;


    pub fn get_auto(&self) -> bool {
        self.auto
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // string gateway = 4;


    pub fn get_gateway(&self) -> &str {
        &self.gateway
    }

    // string netmask = 5;


    pub fn get_netmask(&self) -> &str {
        &self.netmask
    }

    // int32 mtu = 6;


    pub fn get_mtu(&self) -> i32 {
        self.mtu
    }

    // repeated string fake_dns_exclude = 7;


    pub fn get_fake_dns_exclude(&self) -> &[::std::string::String] {
        &self.fake_dns_exclude
    }

    // repeated string fake_dns_include = 8;


    pub fn get_fake_dns_include(&self) -> &[::std::string::String] {
        &self.fake_dns_include
    }
}

impl ::protobuf::Message for TunInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fd = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gateway)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.netmask)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mtu = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fake_dns_exclude)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fake_dns_include)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fd != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fd, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.auto != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if !self.gateway.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.gateway);
        }
        if !self.netmask.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.netmask);
        }
        if self.mtu != 0 {
            my_size += ::protobuf::rt::value_size(6, self.mtu, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fake_dns_exclude {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.fake_dns_include {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fd != 0 {
            os.write_int32(1, self.fd)?;
        }
        if self.auto != false {
            os.write_bool(9, self.auto)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if !self.gateway.is_empty() {
            os.write_string(4, &self.gateway)?;
        }
        if !self.netmask.is_empty() {
            os.write_string(5, &self.netmask)?;
        }
        if self.mtu != 0 {
            os.write_int32(6, self.mtu)?;
        }
        for v in &self.fake_dns_exclude {
            os.write_string(7, &v)?;
        };
        for v in &self.fake_dns_include {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TunInboundSettings {
        TunInboundSettings::new()
    }

    fn default_instance() -> &'static TunInboundSettings {
        static instance: ::protobuf::rt::LazyV2<TunInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TunInboundSettings::new)
    }
}

impl ::protobuf::Clear for TunInboundSettings {
    fn clear(&mut self) {
        self.fd = 0;
        self.auto = false;
        self.name.clear();
        self.address.clear();
        self.gateway.clear();
        self.netmask.clear();
        self.mtu = 0;
        self.fake_dns_exclude.clear();
        self.fake_dns_include.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TunInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShadowsocksInboundSettings {
    // message fields
    pub method: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShadowsocksInboundSettings {
    fn default() -> &'a ShadowsocksInboundSettings {
        <ShadowsocksInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ShadowsocksInboundSettings {
    pub fn new() -> ShadowsocksInboundSettings {
        ::std::default::Default::default()
    }

    // string method = 1;


    pub fn get_method(&self) -> &str {
        &self.method
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for ShadowsocksInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.method);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.method.is_empty() {
            os.write_string(1, &self.method)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShadowsocksInboundSettings {
        ShadowsocksInboundSettings::new()
    }

    fn default_instance() -> &'static ShadowsocksInboundSettings {
        static instance: ::protobuf::rt::LazyV2<ShadowsocksInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShadowsocksInboundSettings::new)
    }
}

impl ::protobuf::Clear for ShadowsocksInboundSettings {
    fn clear(&mut self) {
        self.method.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ShadowsocksInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrojanInboundSettings {
    // message fields
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrojanInboundSettings {
    fn default() -> &'a TrojanInboundSettings {
        <TrojanInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TrojanInboundSettings {
    pub fn new() -> TrojanInboundSettings {
        ::std::default::Default::default()
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for TrojanInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrojanInboundSettings {
        TrojanInboundSettings::new()
    }

    fn default_instance() -> &'static TrojanInboundSettings {
        static instance: ::protobuf::rt::LazyV2<TrojanInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrojanInboundSettings::new)
    }
}

impl ::protobuf::Clear for TrojanInboundSettings {
    fn clear(&mut self) {
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TrojanInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebSocketInboundSettings {
    // message fields
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebSocketInboundSettings {
    fn default() -> &'a WebSocketInboundSettings {
        <WebSocketInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl WebSocketInboundSettings {
    pub fn new() -> WebSocketInboundSettings {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
}

impl ::protobuf::Message for WebSocketInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebSocketInboundSettings {
        WebSocketInboundSettings::new()
    }

    fn default_instance() -> &'static WebSocketInboundSettings {
        static instance: ::protobuf::rt::LazyV2<WebSocketInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebSocketInboundSettings::new)
    }
}

impl ::protobuf::Clear for WebSocketInboundSettings {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for WebSocketInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AMuxInboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AMuxInboundSettings {
    fn default() -> &'a AMuxInboundSettings {
        <AMuxInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl AMuxInboundSettings {
    pub fn new() -> AMuxInboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
}

impl ::protobuf::Message for AMuxInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AMuxInboundSettings {
        AMuxInboundSettings::new()
    }

    fn default_instance() -> &'static AMuxInboundSettings {
        static instance: ::protobuf::rt::LazyV2<AMuxInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AMuxInboundSettings::new)
    }
}

impl ::protobuf::Clear for AMuxInboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AMuxInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuicInboundSettings {
    // message fields
    pub certificate: ::std::string::String,
    pub certificate_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuicInboundSettings {
    fn default() -> &'a QuicInboundSettings {
        <QuicInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl QuicInboundSettings {
    pub fn new() -> QuicInboundSettings {
        ::std::default::Default::default()
    }

    // string certificate = 1;


    pub fn get_certificate(&self) -> &str {
        &self.certificate
    }

    // string certificate_key = 2;


    pub fn get_certificate_key(&self) -> &str {
        &self.certificate_key
    }
}

impl ::protobuf::Message for QuicInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.certificate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.certificate_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.certificate);
        }
        if !self.certificate_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.certificate_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.certificate.is_empty() {
            os.write_string(1, &self.certificate)?;
        }
        if !self.certificate_key.is_empty() {
            os.write_string(2, &self.certificate_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuicInboundSettings {
        QuicInboundSettings::new()
    }

    fn default_instance() -> &'static QuicInboundSettings {
        static instance: ::protobuf::rt::LazyV2<QuicInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuicInboundSettings::new)
    }
}

impl ::protobuf::Clear for QuicInboundSettings {
    fn clear(&mut self) {
        self.certificate.clear();
        self.certificate_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuicInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChainInboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainInboundSettings {
    fn default() -> &'a ChainInboundSettings {
        <ChainInboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ChainInboundSettings {
    pub fn new() -> ChainInboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
}

impl ::protobuf::Message for ChainInboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainInboundSettings {
        ChainInboundSettings::new()
    }

    fn default_instance() -> &'static ChainInboundSettings {
        static instance: ::protobuf::rt::LazyV2<ChainInboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainInboundSettings::new)
    }
}

impl ::protobuf::Clear for ChainInboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainInboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Inbound {
    // message fields
    pub tag: ::std::string::String,
    pub protocol: ::std::string::String,
    pub address: ::std::string::String,
    pub port: u32,
    pub settings: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Inbound {
    fn default() -> &'a Inbound {
        <Inbound as ::protobuf::Message>::default_instance()
    }
}

impl Inbound {
    pub fn new() -> Inbound {
        ::std::default::Default::default()
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }

    // string protocol = 2;


    pub fn get_protocol(&self) -> &str {
        &self.protocol
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 4;


    pub fn get_port(&self) -> u32 {
        self.port
    }

    // bytes settings = 5;


    pub fn get_settings(&self) -> &[u8] {
        &self.settings
    }
}

impl ::protobuf::Message for Inbound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(4, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.settings.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.settings);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(4, self.port)?;
        }
        if !self.settings.is_empty() {
            os.write_bytes(5, &self.settings)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Inbound {
        Inbound::new()
    }

    fn default_instance() -> &'static Inbound {
        static instance: ::protobuf::rt::LazyV2<Inbound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Inbound::new)
    }
}

impl ::protobuf::Clear for Inbound {
    fn clear(&mut self) {
        self.tag.clear();
        self.protocol.clear();
        self.address.clear();
        self.port = 0;
        self.settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Inbound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RedirectOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectOutboundSettings {
    fn default() -> &'a RedirectOutboundSettings {
        <RedirectOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl RedirectOutboundSettings {
    pub fn new() -> RedirectOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
}

impl ::protobuf::Message for RedirectOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectOutboundSettings {
        RedirectOutboundSettings::new()
    }

    fn default_instance() -> &'static RedirectOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<RedirectOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedirectOutboundSettings::new)
    }
}

impl ::protobuf::Clear for RedirectOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SocksOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SocksOutboundSettings {
    fn default() -> &'a SocksOutboundSettings {
        <SocksOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl SocksOutboundSettings {
    pub fn new() -> SocksOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }
}

impl ::protobuf::Message for SocksOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SocksOutboundSettings {
        SocksOutboundSettings::new()
    }

    fn default_instance() -> &'static SocksOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<SocksOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SocksOutboundSettings::new)
    }
}

impl ::protobuf::Clear for SocksOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SocksOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ShadowsocksOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub method: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShadowsocksOutboundSettings {
    fn default() -> &'a ShadowsocksOutboundSettings {
        <ShadowsocksOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ShadowsocksOutboundSettings {
    pub fn new() -> ShadowsocksOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }

    // string method = 3;


    pub fn get_method(&self) -> &str {
        &self.method
    }

    // string password = 4;


    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for ShadowsocksOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.method);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.method.is_empty() {
            os.write_string(3, &self.method)?;
        }
        if !self.password.is_empty() {
            os.write_string(4, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShadowsocksOutboundSettings {
        ShadowsocksOutboundSettings::new()
    }

    fn default_instance() -> &'static ShadowsocksOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<ShadowsocksOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShadowsocksOutboundSettings::new)
    }
}

impl ::protobuf::Clear for ShadowsocksOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.method.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ShadowsocksOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrojanOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrojanOutboundSettings {
    fn default() -> &'a TrojanOutboundSettings {
        <TrojanOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TrojanOutboundSettings {
    pub fn new() -> TrojanOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for TrojanOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrojanOutboundSettings {
        TrojanOutboundSettings::new()
    }

    fn default_instance() -> &'static TrojanOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<TrojanOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrojanOutboundSettings::new)
    }
}

impl ::protobuf::Clear for TrojanOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TrojanOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct VMessOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub uuid: ::std::string::String,
    pub security: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VMessOutboundSettings {
    fn default() -> &'a VMessOutboundSettings {
        <VMessOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl VMessOutboundSettings {
    pub fn new() -> VMessOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }

    // string uuid = 3;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }

    // string security = 4;


    pub fn get_security(&self) -> &str {
        &self.security
    }
}

impl ::protobuf::Message for VMessOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.security)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.uuid);
        }
        if !self.security.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.security);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(3, &self.uuid)?;
        }
        if !self.security.is_empty() {
            os.write_string(4, &self.security)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VMessOutboundSettings {
        VMessOutboundSettings::new()
    }

    fn default_instance() -> &'static VMessOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<VMessOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VMessOutboundSettings::new)
    }
}

impl ::protobuf::Clear for VMessOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.uuid.clear();
        self.security.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for VMessOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TlsOutboundSettings {
    // message fields
    pub server_name: ::std::string::String,
    pub alpn: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TlsOutboundSettings {
    fn default() -> &'a TlsOutboundSettings {
        <TlsOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TlsOutboundSettings {
    pub fn new() -> TlsOutboundSettings {
        ::std::default::Default::default()
    }

    // string server_name = 1;


    pub fn get_server_name(&self) -> &str {
        &self.server_name
    }

    // repeated string alpn = 2;


    pub fn get_alpn(&self) -> &[::std::string::String] {
        &self.alpn
    }
}

impl ::protobuf::Message for TlsOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.alpn)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.server_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.server_name);
        }
        for value in &self.alpn {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.server_name.is_empty() {
            os.write_string(1, &self.server_name)?;
        }
        for v in &self.alpn {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TlsOutboundSettings {
        TlsOutboundSettings::new()
    }

    fn default_instance() -> &'static TlsOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<TlsOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TlsOutboundSettings::new)
    }
}

impl ::protobuf::Clear for TlsOutboundSettings {
    fn clear(&mut self) {
        self.server_name.clear();
        self.alpn.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TlsOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct WebSocketOutboundSettings {
    // message fields
    pub path: ::std::string::String,
    pub headers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WebSocketOutboundSettings {
    fn default() -> &'a WebSocketOutboundSettings {
        <WebSocketOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl WebSocketOutboundSettings {
    pub fn new() -> WebSocketOutboundSettings {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }

    // repeated .WebSocketOutboundSettings.HeadersEntry headers = 2;


    pub fn get_headers(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.headers
    }
}

impl ::protobuf::Message for WebSocketOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.headers);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.headers, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WebSocketOutboundSettings {
        WebSocketOutboundSettings::new()
    }

    fn default_instance() -> &'static WebSocketOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<WebSocketOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WebSocketOutboundSettings::new)
    }
}

impl ::protobuf::Clear for WebSocketOutboundSettings {
    fn clear(&mut self) {
        self.path.clear();
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for WebSocketOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct HTTP2OutboundSettings {
    // message fields
    pub path: ::std::string::String,
    pub host: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTP2OutboundSettings {
    fn default() -> &'a HTTP2OutboundSettings {
        <HTTP2OutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl HTTP2OutboundSettings {
    pub fn new() -> HTTP2OutboundSettings {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
}

impl ::protobuf::Message for HTTP2OutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTP2OutboundSettings {
        HTTP2OutboundSettings::new()
    }

    fn default_instance() -> &'static HTTP2OutboundSettings {
        static instance: ::protobuf::rt::LazyV2<HTTP2OutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTP2OutboundSettings::new)
    }
}

impl ::protobuf::Clear for HTTP2OutboundSettings {
    fn clear(&mut self) {
        self.path.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTP2OutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TryAllOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    pub delay_base: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TryAllOutboundSettings {
    fn default() -> &'a TryAllOutboundSettings {
        <TryAllOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl TryAllOutboundSettings {
    pub fn new() -> TryAllOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }

    // uint32 delay_base = 2;


    pub fn get_delay_base(&self) -> u32 {
        self.delay_base
    }
}

impl ::protobuf::Message for TryAllOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_base = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.delay_base != 0 {
            my_size += ::protobuf::rt::value_size(2, self.delay_base, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.delay_base != 0 {
            os.write_uint32(2, self.delay_base)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TryAllOutboundSettings {
        TryAllOutboundSettings::new()
    }

    fn default_instance() -> &'static TryAllOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<TryAllOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TryAllOutboundSettings::new)
    }
}

impl ::protobuf::Clear for TryAllOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.delay_base = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TryAllOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RandomOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandomOutboundSettings {
    fn default() -> &'a RandomOutboundSettings {
        <RandomOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl RandomOutboundSettings {
    pub fn new() -> RandomOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
}

impl ::protobuf::Message for RandomOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandomOutboundSettings {
        RandomOutboundSettings::new()
    }

    fn default_instance() -> &'static RandomOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<RandomOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandomOutboundSettings::new)
    }
}

impl ::protobuf::Clear for RandomOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AMuxOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    pub max_accepts: u32,
    pub concurrency: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AMuxOutboundSettings {
    fn default() -> &'a AMuxOutboundSettings {
        <AMuxOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl AMuxOutboundSettings {
    pub fn new() -> AMuxOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }

    // repeated string actors = 3;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }

    // uint32 max_accepts = 4;


    pub fn get_max_accepts(&self) -> u32 {
        self.max_accepts
    }

    // uint32 concurrency = 5;


    pub fn get_concurrency(&self) -> u32 {
        self.concurrency
    }
}

impl ::protobuf::Message for AMuxOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_accepts = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.concurrency = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.max_accepts != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_accepts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.concurrency != 0 {
            my_size += ::protobuf::rt::value_size(5, self.concurrency, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        for v in &self.actors {
            os.write_string(3, &v)?;
        };
        if self.max_accepts != 0 {
            os.write_uint32(4, self.max_accepts)?;
        }
        if self.concurrency != 0 {
            os.write_uint32(5, self.concurrency)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AMuxOutboundSettings {
        AMuxOutboundSettings::new()
    }

    fn default_instance() -> &'static AMuxOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<AMuxOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AMuxOutboundSettings::new)
    }
}

impl ::protobuf::Clear for AMuxOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.actors.clear();
        self.max_accepts = 0;
        self.concurrency = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AMuxOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuicOutboundSettings {
    // message fields
    pub address: ::std::string::String,
    pub port: u32,
    pub server_name: ::std::string::String,
    pub certificate: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuicOutboundSettings {
    fn default() -> &'a QuicOutboundSettings {
        <QuicOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl QuicOutboundSettings {
    pub fn new() -> QuicOutboundSettings {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint32 port = 2;


    pub fn get_port(&self) -> u32 {
        self.port
    }

    // string server_name = 3;


    pub fn get_server_name(&self) -> &str {
        &self.server_name
    }

    // string certificate = 4;


    pub fn get_certificate(&self) -> &str {
        &self.certificate
    }
}

impl ::protobuf::Message for QuicOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.certificate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.server_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.server_name);
        }
        if !self.certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.certificate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if self.port != 0 {
            os.write_uint32(2, self.port)?;
        }
        if !self.server_name.is_empty() {
            os.write_string(3, &self.server_name)?;
        }
        if !self.certificate.is_empty() {
            os.write_string(4, &self.certificate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuicOutboundSettings {
        QuicOutboundSettings::new()
    }

    fn default_instance() -> &'static QuicOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<QuicOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuicOutboundSettings::new)
    }
}

impl ::protobuf::Clear for QuicOutboundSettings {
    fn clear(&mut self) {
        self.address.clear();
        self.port = 0;
        self.server_name.clear();
        self.certificate.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for QuicOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChainOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainOutboundSettings {
    fn default() -> &'a ChainOutboundSettings {
        <ChainOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl ChainOutboundSettings {
    pub fn new() -> ChainOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
}

impl ::protobuf::Message for ChainOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainOutboundSettings {
        ChainOutboundSettings::new()
    }

    fn default_instance() -> &'static ChainOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<ChainOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainOutboundSettings::new)
    }
}

impl ::protobuf::Clear for ChainOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RetryOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    pub attempts: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryOutboundSettings {
    fn default() -> &'a RetryOutboundSettings {
        <RetryOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl RetryOutboundSettings {
    pub fn new() -> RetryOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }

    // uint32 attempts = 2;


    pub fn get_attempts(&self) -> u32 {
        self.attempts
    }
}

impl ::protobuf::Message for RetryOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attempts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.attempts != 0 {
            my_size += ::protobuf::rt::value_size(2, self.attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.attempts != 0 {
            os.write_uint32(2, self.attempts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryOutboundSettings {
        RetryOutboundSettings::new()
    }

    fn default_instance() -> &'static RetryOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<RetryOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryOutboundSettings::new)
    }
}

impl ::protobuf::Clear for RetryOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.attempts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FailOverOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    pub fail_timeout: u32,
    pub health_check: bool,
    pub check_interval: u32,
    pub failover: bool,
    pub fallback_cache: bool,
    pub cache_size: u32,
    pub cache_timeout: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FailOverOutboundSettings {
    fn default() -> &'a FailOverOutboundSettings {
        <FailOverOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl FailOverOutboundSettings {
    pub fn new() -> FailOverOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }

    // uint32 fail_timeout = 2;


    pub fn get_fail_timeout(&self) -> u32 {
        self.fail_timeout
    }

    // bool health_check = 3;


    pub fn get_health_check(&self) -> bool {
        self.health_check
    }

    // uint32 check_interval = 4;


    pub fn get_check_interval(&self) -> u32 {
        self.check_interval
    }

    // bool failover = 5;


    pub fn get_failover(&self) -> bool {
        self.failover
    }

    // bool fallback_cache = 6;


    pub fn get_fallback_cache(&self) -> bool {
        self.fallback_cache
    }

    // uint32 cache_size = 7;


    pub fn get_cache_size(&self) -> u32 {
        self.cache_size
    }

    // uint32 cache_timeout = 8;


    pub fn get_cache_timeout(&self) -> u32 {
        self.cache_timeout
    }
}

impl ::protobuf::Message for FailOverOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fail_timeout = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.health_check = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.check_interval = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failover = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fallback_cache = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cache_size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cache_timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.fail_timeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.fail_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.health_check != false {
            my_size += 2;
        }
        if self.check_interval != 0 {
            my_size += ::protobuf::rt::value_size(4, self.check_interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.failover != false {
            my_size += 2;
        }
        if self.fallback_cache != false {
            my_size += 2;
        }
        if self.cache_size != 0 {
            my_size += ::protobuf::rt::value_size(7, self.cache_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cache_timeout != 0 {
            my_size += ::protobuf::rt::value_size(8, self.cache_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        if self.fail_timeout != 0 {
            os.write_uint32(2, self.fail_timeout)?;
        }
        if self.health_check != false {
            os.write_bool(3, self.health_check)?;
        }
        if self.check_interval != 0 {
            os.write_uint32(4, self.check_interval)?;
        }
        if self.failover != false {
            os.write_bool(5, self.failover)?;
        }
        if self.fallback_cache != false {
            os.write_bool(6, self.fallback_cache)?;
        }
        if self.cache_size != 0 {
            os.write_uint32(7, self.cache_size)?;
        }
        if self.cache_timeout != 0 {
            os.write_uint32(8, self.cache_timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FailOverOutboundSettings {
        FailOverOutboundSettings::new()
    }

    fn default_instance() -> &'static FailOverOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<FailOverOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FailOverOutboundSettings::new)
    }
}

impl ::protobuf::Clear for FailOverOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.fail_timeout = 0;
        self.health_check = false;
        self.check_interval = 0;
        self.failover = false;
        self.fallback_cache = false;
        self.cache_size = 0;
        self.cache_timeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FailOverOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectOutboundSettings {
    // message fields
    pub actors: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectOutboundSettings {
    fn default() -> &'a SelectOutboundSettings {
        <SelectOutboundSettings as ::protobuf::Message>::default_instance()
    }
}

impl SelectOutboundSettings {
    pub fn new() -> SelectOutboundSettings {
        ::std::default::Default::default()
    }

    // repeated string actors = 1;


    pub fn get_actors(&self) -> &[::std::string::String] {
        &self.actors
    }
}

impl ::protobuf::Message for SelectOutboundSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.actors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actors {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectOutboundSettings {
        SelectOutboundSettings::new()
    }

    fn default_instance() -> &'static SelectOutboundSettings {
        static instance: ::protobuf::rt::LazyV2<SelectOutboundSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectOutboundSettings::new)
    }
}

impl ::protobuf::Clear for SelectOutboundSettings {
    fn clear(&mut self) {
        self.actors.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectOutboundSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Outbound {
    // message fields
    pub tag: ::std::string::String,
    pub protocol: ::std::string::String,
    pub bind: ::std::string::String,
    pub settings: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Outbound {
    fn default() -> &'a Outbound {
        <Outbound as ::protobuf::Message>::default_instance()
    }
}

impl Outbound {
    pub fn new() -> Outbound {
        ::std::default::Default::default()
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }

    // string protocol = 2;


    pub fn get_protocol(&self) -> &str {
        &self.protocol
    }

    // string bind = 3;


    pub fn get_bind(&self) -> &str {
        &self.bind
    }

    // bytes settings = 4;


    pub fn get_settings(&self) -> &[u8] {
        &self.settings
    }
}

impl ::protobuf::Message for Outbound {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bind)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if !self.protocol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.protocol);
        }
        if !self.bind.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.bind);
        }
        if !self.settings.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.settings);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if !self.protocol.is_empty() {
            os.write_string(2, &self.protocol)?;
        }
        if !self.bind.is_empty() {
            os.write_string(3, &self.bind)?;
        }
        if !self.settings.is_empty() {
            os.write_bytes(4, &self.settings)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Outbound {
        Outbound::new()
    }

    fn default_instance() -> &'static Outbound {
        static instance: ::protobuf::rt::LazyV2<Outbound> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Outbound::new)
    }
}

impl ::protobuf::Clear for Outbound {
    fn clear(&mut self) {
        self.tag.clear();
        self.protocol.clear();
        self.bind.clear();
        self.settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Outbound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Router {
    // message fields
    pub rules: ::protobuf::RepeatedField<Router_Rule>,
    pub domain_resolve: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Router {
    fn default() -> &'a Router {
        <Router as ::protobuf::Message>::default_instance()
    }
}

impl Router {
    pub fn new() -> Router {
        ::std::default::Default::default()
    }

    // repeated .Router.Rule rules = 1;


    pub fn get_rules(&self) -> &[Router_Rule] {
        &self.rules
    }

    // bool domain_resolve = 2;


    pub fn get_domain_resolve(&self) -> bool {
        self.domain_resolve
    }
}

impl ::protobuf::Message for Router {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.domain_resolve = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.domain_resolve != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.domain_resolve != false {
            os.write_bool(2, self.domain_resolve)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Router {
        Router::new()
    }

    fn default_instance() -> &'static Router {
        static instance: ::protobuf::rt::LazyV2<Router> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Router::new)
    }
}

impl ::protobuf::Clear for Router {
    fn clear(&mut self) {
        self.rules.clear();
        self.domain_resolve = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Router {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Router_Rule {
    // message fields
    pub target_tag: ::std::string::String,
    pub domains: ::protobuf::RepeatedField<Router_Rule_Domain>,
    pub ip_cidrs: ::protobuf::RepeatedField<::std::string::String>,
    pub mmdbs: ::protobuf::RepeatedField<Router_Rule_Mmdb>,
    pub port_ranges: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Router_Rule {
    fn default() -> &'a Router_Rule {
        <Router_Rule as ::protobuf::Message>::default_instance()
    }
}

impl Router_Rule {
    pub fn new() -> Router_Rule {
        ::std::default::Default::default()
    }

    // string target_tag = 1;


    pub fn get_target_tag(&self) -> &str {
        &self.target_tag
    }

    // repeated .Router.Rule.Domain domains = 2;


    pub fn get_domains(&self) -> &[Router_Rule_Domain] {
        &self.domains
    }

    // repeated string ip_cidrs = 3;


    pub fn get_ip_cidrs(&self) -> &[::std::string::String] {
        &self.ip_cidrs
    }

    // repeated .Router.Rule.Mmdb mmdbs = 4;


    pub fn get_mmdbs(&self) -> &[Router_Rule_Mmdb] {
        &self.mmdbs
    }

    // repeated string port_ranges = 5;


    pub fn get_port_ranges(&self) -> &[::std::string::String] {
        &self.port_ranges
    }
}

impl ::protobuf::Message for Router_Rule {
    fn is_initialized(&self) -> bool {
        for v in &self.domains {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mmdbs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target_tag)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.domains)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ip_cidrs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mmdbs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.port_ranges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.target_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.target_tag);
        }
        for value in &self.domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ip_cidrs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.mmdbs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.port_ranges {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.target_tag.is_empty() {
            os.write_string(1, &self.target_tag)?;
        }
        for v in &self.domains {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ip_cidrs {
            os.write_string(3, &v)?;
        };
        for v in &self.mmdbs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.port_ranges {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Router_Rule {
        Router_Rule::new()
    }

    fn default_instance() -> &'static Router_Rule {
        static instance: ::protobuf::rt::LazyV2<Router_Rule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Router_Rule::new)
    }
}

impl ::protobuf::Clear for Router_Rule {
    fn clear(&mut self) {
        self.target_tag.clear();
        self.domains.clear();
        self.ip_cidrs.clear();
        self.mmdbs.clear();
        self.port_ranges.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Router_Rule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Router_Rule_Domain {
    // message fields
    pub field_type: Router_Rule_Domain_Type,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Router_Rule_Domain {
    fn default() -> &'a Router_Rule_Domain {
        <Router_Rule_Domain as ::protobuf::Message>::default_instance()
    }
}

impl Router_Rule_Domain {
    pub fn new() -> Router_Rule_Domain {
        ::std::default::Default::default()
    }

    // .Router.Rule.Domain.Type type = 1;


    pub fn get_field_type(&self) -> Router_Rule_Domain_Type {
        self.field_type
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
}

impl ::protobuf::Message for Router_Rule_Domain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Router_Rule_Domain_Type::PLAIN {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Router_Rule_Domain_Type::PLAIN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Router_Rule_Domain {
        Router_Rule_Domain::new()
    }

    fn default_instance() -> &'static Router_Rule_Domain {
        static instance: ::protobuf::rt::LazyV2<Router_Rule_Domain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Router_Rule_Domain::new)
    }
}

impl ::protobuf::Clear for Router_Rule_Domain {
    fn clear(&mut self) {
        self.field_type = Router_Rule_Domain_Type::PLAIN;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Router_Rule_Domain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Router_Rule_Domain_Type {
    PLAIN = 0,
    DOMAIN = 1,
    FULL = 2,
}

impl ::protobuf::ProtobufEnum for Router_Rule_Domain_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Router_Rule_Domain_Type> {
        match value {
            0 => ::std::option::Option::Some(Router_Rule_Domain_Type::PLAIN),
            1 => ::std::option::Option::Some(Router_Rule_Domain_Type::DOMAIN),
            2 => ::std::option::Option::Some(Router_Rule_Domain_Type::FULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Router_Rule_Domain_Type] = &[
            Router_Rule_Domain_Type::PLAIN,
            Router_Rule_Domain_Type::DOMAIN,
            Router_Rule_Domain_Type::FULL,
        ];
        values
    }
}

impl ::std::marker::Copy for Router_Rule_Domain_Type {
}

impl ::std::default::Default for Router_Rule_Domain_Type {
    fn default() -> Self {
        Router_Rule_Domain_Type::PLAIN
    }
}

impl ::protobuf::reflect::ProtobufValue for Router_Rule_Domain_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Router_Rule_Mmdb {
    // message fields
    pub file: ::std::string::String,
    pub country_code: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Router_Rule_Mmdb {
    fn default() -> &'a Router_Rule_Mmdb {
        <Router_Rule_Mmdb as ::protobuf::Message>::default_instance()
    }
}

impl Router_Rule_Mmdb {
    pub fn new() -> Router_Rule_Mmdb {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }

    // string country_code = 2;


    pub fn get_country_code(&self) -> &str {
        &self.country_code
    }
}

impl ::protobuf::Message for Router_Rule_Mmdb {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.country_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if !self.country_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.country_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if !self.country_code.is_empty() {
            os.write_string(2, &self.country_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Router_Rule_Mmdb {
        Router_Rule_Mmdb::new()
    }

    fn default_instance() -> &'static Router_Rule_Mmdb {
        static instance: ::protobuf::rt::LazyV2<Router_Rule_Mmdb> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Router_Rule_Mmdb::new)
    }
}

impl ::protobuf::Clear for Router_Rule_Mmdb {
    fn clear(&mut self) {
        self.file.clear();
        self.country_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Router_Rule_Mmdb {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Config {
    // message fields
    pub log: ::protobuf::SingularPtrField<Log>,
    pub inbounds: ::protobuf::RepeatedField<Inbound>,
    pub outbounds: ::protobuf::RepeatedField<Outbound>,
    pub router: ::protobuf::SingularPtrField<Router>,
    pub dns: ::protobuf::SingularPtrField<Dns>,
    pub api: ::protobuf::SingularPtrField<Api>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // .Log log = 1;


    pub fn get_log(&self) -> &Log {
        self.log.as_ref().unwrap_or_else(|| <Log as ::protobuf::Message>::default_instance())
    }

    // repeated .Inbound inbounds = 2;


    pub fn get_inbounds(&self) -> &[Inbound] {
        &self.inbounds
    }

    // repeated .Outbound outbounds = 3;


    pub fn get_outbounds(&self) -> &[Outbound] {
        &self.outbounds
    }

    // .Router router = 4;


    pub fn get_router(&self) -> &Router {
        self.router.as_ref().unwrap_or_else(|| <Router as ::protobuf::Message>::default_instance())
    }

    // .Dns dns = 5;


    pub fn get_dns(&self) -> &Dns {
        self.dns.as_ref().unwrap_or_else(|| <Dns as ::protobuf::Message>::default_instance())
    }

    // .Api api = 6;


    pub fn get_api(&self) -> &Api {
        self.api.as_ref().unwrap_or_else(|| <Api as ::protobuf::Message>::default_instance())
    }
}

impl ::protobuf::Message for Config {
    fn is_initialized(&self) -> bool {
        for v in &self.log {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inbounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outbounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.router {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dns {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.api {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.log)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inbounds)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outbounds)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.router)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dns)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.api)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.log.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.inbounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outbounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.router.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dns.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.api.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.log.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.inbounds {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outbounds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.router.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dns.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.api.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config {
        Config::new()
    }

    fn default_instance() -> &'static Config {
        static instance: ::protobuf::rt::LazyV2<Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config::new)
    }
}

impl ::protobuf::Clear for Config {
    fn clear(&mut self) {
        self.log.clear();
        self.inbounds.clear();
        self.outbounds.clear();
        self.router.clear();
        self.dns.clear();
        self.api.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
